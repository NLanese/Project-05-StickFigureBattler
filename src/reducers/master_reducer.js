import { combineReducers } from "redux";
import applyingStatusEffectandDamage from "../helpers/applyingStatusEffectsAndDamage"


const rootReducer = combineReducers({
    battle: manageBattle,
    user: manageUser
  })
  export default rootReducer


// This is in charge of changing or creating a BATTLE instance. This means it will cover the following...
  // 1. Generates a new BATTLE instance with a new OPPONENT BATTLER instance as well in one fetch action
  // 2. This is the reducer that will enable us to make changes to either a USER or OPPONENT state like 
  //    health or status. Def, Atk, and sDef can also be raised on rare occasions.
  // 3. Handles an action that will fire as soon as either the user or opponent's health goes to 0. This ends
  //    the Battle and resets the user's health and clears any status effects. It also handles the leveling up, which 
  //    involves a fetch to send data and alter the user's character in the database
function manageBattle(
    action,
    state={
        figures:{                       // The following figures are temporary as the stats will ne changed during the battle.
            user: {                     // We save the original user stats under the manageUser reducer
                is_user: true,                  // Might be needed. Might not, we'll find out
                name: "",                       // The name of the user figure
                class_type: null,
                id: null,                       // Generated in Rails
                hp: 0,                          // Health
                type: null,                     // Type, one of... TECH, WEAPONRY, SUPERNATURAL, ATHLETIC, NETHER, STEALTH. Each has a different effectiveness on the other
                level: 0,                       // Keeps track of how many fights they have won
                status: "none",                 // Certins moves (generated by Rails) have status effects. This variable holds what effects (if any) are present on the user
                spd: 0,                         // Speed
                atk: 0,                         // Attack
                def: 0,                         // Defense... you get it right?
                sAtk: 0,                        //
                sDef: 0,                        //
                tEffected: 0,                   // How many turns the user has been effected by a status effect. 0 if unaffected 
                image: "N/A",                   // Generated by Rails and used to determine with jpeg to load
                moves: [null]                   // Sets an empty array for the moves and setting that up is gonna suck so I'm avoiding it
            },
            opp: {
                is_user: false,
                name: "",
                class_type: null,
                id: null,                       // See Above
                hp: 0,
                type: null,
                level: 0,
                status: "none",
                spd: 0,
                atk: 0,
                def: 0,
                sAtk: 0,
                sDef: 0,
                tEffected: 0,
                image: "N/A",
                moves: [null]
            }
        },
        battle_details: {
            turns: 0,                           // This will keep track of the turns elapsed
            whoseTurn_id: null,                     // This will be set to 'user', 'opp', or 'none'. 
            this_move_target_id: null,
            prompt: "Welcome"
        }
    }
){
    switch (action.type) {
        case 'NEW_BATTLE':
        // FETCH NEW BATTLE JSON

        case 'CHANGE_USER_HP':
            // action = {type: "CHANGE_OPP_HP", amount: {Number generated in Event Listener inside of Moves}, effect: {String generated in Event Listener} }
            let effect = action.effect
            let newUserState = applyingStatusEffectandDamage(state, action.amount, effect)
            return {newUserState}

        case 'CHANGE_OPP_HP':
            // action = {type: "CHANGE_OPP_HP", amount: {Number generated in Event Listener inside of Moves}, effect: {String generated in Event Listener} }
            effect = action.effect
            let newOppState = applyingStatusEffectandDamage(state, action.amount, effect)
            return {newOppState}

        case 'COMPLETE_BATTLE':
            // CHANGE PROMPT, RESET USER HP, LEVEL UP
        
        default:
            return state;
    }
};

function manageUser(
    action, 
    state= 
        {
            name: null,
            created: false,
            id: null,                       // Generated in Rails
            hp: 0,                          // Health
            class_type: null,
            type: null,                     // Type, one of... TECH, WEAPONRY, SUPERNATURAL, ATHLETIC, NETHER, STEALTH. Each has a different effectiveness on the other
            level: 0,                       // Keeps track of how many fights they have won
            status: "none",                 // Certins moves (generated by Rails) have status effects. This variable holds what effects (if any) are present on the user
            spd: 0,                         // Speed
            atk: 0,                         // Attack
            def: 0,                         // Defense... you get it right?
            sAtk: 0,                        //
            sDef: 0,                        //
            tEffected: 0,                   // How many turns the user has been effected by a status effect. 0 if unaffected 
            image: "N/A",                   // Generated by Rails and used to determine with jpeg to load
            moves: [null, null, null, null]                   // Sets an empty array for the moves and setting that up is gonna suck so I'm avoiding it
        }
){
    switch(action.type){
    // {type: "CREATE_USER_NAME", payload: "Sample Name"}
        case('CREATE_USER_NAME'):
            return {...state, user: {...state.user, name: action.payload}}
    // {type: "REPLACE_USER_MOVE", payload: <move object generated in LevelUp.js>, index: <index of move being removed> }
        case('REPLACE_USER_MOVE'):
            let newMoves = state.moves // clones the user's current moves
            newMoves[action.index] = action.payload // finds the index of the moves that's being replaced from the local newMoves variable, and changes it to the new move
            return {...state, user:{...state.user, moves: newMoves}} // changes the state's movs to match the local newMoves array's values.
        case('CREATE_USER_FIGURE'):
            
        
    }
}
